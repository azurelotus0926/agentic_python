# Building and running agents

### Terminology

An "agent" is an LLM-powered program that is defined in code. You can run an agent one or
more times at once.

The persistent history of your interactions with an agent consitute a _session_. The LLM
context is preserved as long as the session continues. Once a new session is started then
the _context_ goes back to the initial state.

Each interaction of: user request -> agent thinking -> agent response is called a _turn_.
A single session can include many turns. 

As your agent operates, it may take multiple _steps_ in order to complete a turn. Generally
each step will result in either a _completion_ - the generation of some text, or a _function call_,
or both together. Tracing the steps of your agent inside of a turn is done by reviewing the logs
generated by the agent.

--------------

Construct an Agent like this:

```python
from agentic.common import Agent

def weather_tool():
    return "The weather is nice today."


agent = Agent(
    name="Basic Agent",
    welcome="I am a simple agent here to help answer your weather questions.",
    instructions="You are a helpful assistant.",
    model="openai/gpt-4o-mini",
    tools=[WeatherTool()],
)
```

The `instructions` set the "system prompt" for the LLM. The "welcome message" is just a string
that can be displayed to the end user to help them use the agent.

Optional parameters to your agent include:

    max_tokens - The maximum number of tokens to generate on each completion
    debug - The debugging level you want the agent to observe
    memories - A list of facts to inject into the Agent's context for every session

See [models](./Models.md) for information on using different models. 

See [tools](./Tools.md) for information on creating and using tools.

## Settings and Secrets

When your agent runs it will likely need api keys for various services. You can set these
keys in your environment, but this approach gets very unwieldy with lots of keys.

Agentic includes a simple system for managing `settings` and `secrets`. Both are stored
in a local SQLite database file (inside `~/.agentic`), but the secrets are encrypted.

    agentic list            - list your settings
    agentic list-secrets    - list your secrets

    agentic set <setting> <value> 
    agentic get <setting>        
    
    agentic set-secret <secret name> <value>
    agentic get-secret <secret name>

All settings and secrets are automatically injected into the environment when your agent runs,
but it is recommended to get values from the `RunContext` using `get_config` and `get_secret`.
One nice feature is that secrets can be stored in a `namespace` named after your agent, so
that you can manage multiple values across different agents.

## Using _AgentRunner_ and the REPL

The `AgentRunner` class is a convenience utility for running a **repl** to interact with your
agent:

```
from agentic.common import Agent, AgentRunner

agent = Agent(...)

if __name__ == 'main':
    AgentRunner(agent).run_repl()
```

By default it maintains a persistent session with your agent, so that each turn is appending
to the active session. 

```sh
% python examples/basic_agent.py 
I am a simple agent here to help answer your weather questions.
press <enter> to quit
[Basic Agent]> my name is scott
Hello, Scott! How can I assist you today?
[Basic Agent]> what is my name ?
Your name is Scott.
[openai/gpt-4o-mini: 1 calls, tokens: 12 -> 5, 0.00 cents, time: 0.73s tc: 0.00 c, ctx: 40]
```

The runner repl includes a set of "dot" system commands:

```
> .help

    .agent - Show the state of the active agent
    .run <agent name> - switch the active agent
    .history - show the history of the current session
    .debug [<level>] - enable debug. Defaults to 'tools', or one of 'llm', 'tools', 'all', 'off'
    .settings - show the current config settings
    .help - Show this help
    .quit - Quit the REPL
```

Examples:

```
[Basic Agent]> .agent
Basic Agent
You are a helpful assistant.
tools:
  WeatherTool
```

The **.debug** command is especially helpful to activate different kinds of tracing:

    .debug tools    - Shows logging for tool start/finish events
    .debug llm      - Shows all LLM completion calls
    .debug agents   - Only log events where an agent starts a turn
    .debug all      - Logs everything

We often run with `.debug tools` to track what our agents are doing.

### Things to note

We have used the convenience `repl_loop` in `AgentRunner` to interface to our agent.
But we can write our own loop (or API or whatever) to run our agent:

```python

runner = AgentRunner(agent)
while True:
    request = input("prompt> ")
    for event in runner.next_turn(request):
        print("Agent event: ", event)
```

The `next_turn` function will keep emitting events until the current turn of the agent is
complete. We can loop again and let the user request another task from the agent.

Because you are getting fine-grained events as the agent runs, you can
choose to do other things in the middle, including things like modifying the agent
by giving it more tools. Even though this interface looks like the agent is
"running" some thread (like in Langchain), in fact the agent runs step by step, generating
events along the way, but it can stop at any time.

See more about [events](./Events.md).

# Agentic CLI

Commands:

    --help          - Get help

    models          - list some popular LLM models
    list            - List all settings.
    set             - Set a config value.
    get             - Get a config value.
    delete          - Delete a config value.

    list-secrets    List all secrets.
    set-secret      Set a secret.
    get-secret      Get a secret.
    delete-secret   Delete a secret.

    ollama          - List the latest popular models from Ollama. Use "ollama pull <model> to download.
    ui              - Runs the agentic UI
    claude          - Runs a completion with Anthropic's Claude sonnet model
    gpt             - Runs a completion with OpenAI's GPT-4o-mini model. Use --model to override.


